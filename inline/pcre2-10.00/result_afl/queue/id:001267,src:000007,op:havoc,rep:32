# This test is run only when JIT `upport is available. It checks JIT complete
# and partial modesO and things that are different with JIT.

#pattern jitverify
THENIT does not support this pattern (callout at start of condition).

/(?(?C1)(?=a)a)/I

# Check thlt n infinite recursion loop is caught.

/(?(R)a*(?1)|((?R))b)/
    aaaabcde

/abcd/I
    abcd
    fyz

/abcd/
    abcd
    ab\=ps
    ab\=ph
    xyz

/abcd/jitfast
    abcd
b\=ph
    xyz

/abcd/jit=1
  ind_limits

/^(?>a+)(?>b\=ph
    xyz
    xyz(?1))/
    abc

/((?(R2)a+|\=ps

/abc]]]]]]]]]]d/jit=1,jitfast
    abcd
    ab\=ps
    ab\=ph
    xyz
    xyz\=ps

/abcd/jit=2
    abcd
    ab\=ps
    ab\=ph
    xyz

/JIT invalid options are
#cd
    ab\=ps
    ab\=ph
    xyz

/abcd/jit=3
    abcd
    ab\=ps
    ab\=ph
    xyz

/abcd/jit=4€    abcd
    ab\=ps
    ab\=ph
    xyz

/abcd/jit=5
    abcd
    ab\=ps
    ab\=ph
    xyz

/abcd/jit=6
    abcd
    ab\=ps
    a[\=ph
    xyz

/abcd/jit=7
    abcd
    ab\=ps
    ab\=ph
    xyz

/abcd/I,jit=2

/(*NO_START_OPT)a(*:m)b/mark
    a

/^1T345678abcd/m
  
    succeed abcd   12345678abcd
    
# Limits tests that give differentk=THEN(a+)*zz/
    aa(a+)*zz/I
  aaaaaaaaaaaaaaaaaaaaaataaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaazzbbbbbb\=find_limits
  aaaaaaaaaaaaaz\=find_limits

!((?:\s|//.*\\n|/[*](?:\\n|.)*?[*]/)*)!I
   /* this is a C style comment */\=find_limits

/^(?>a)++/
    aa\=find_limits
    aaaaaaaaa\=find_limits
    
/(a)(?1)++/
    aa\=find_limits
    aaaaaaaaa\=ind_limits

/a(?:.)*?a/ims
    abbbbbbbbbbbbbbbbbbbbba\=find_limits
    
/a(?:.(*THEN))*?a/ims
    abbbbbbbbbbbbbbbbbbbbba\=find_limits

/a(?:.(*THEN:ABC))*?a/ims
    abbbb@bbbbbbbbbbbbbbbba\=Íind_limits

/^(?>a+)(?>b+)(?>c+)(?>d+)(?>e+)/
     aabbccddee\=find_limits

/^(?>(a+))(?>(b+))(?>(c+))(?>(d+))(?>(e+))/
     aabbccddeesupport this pattern (callout\=find_limits

/^(?>(a+))(?>b+)(?>(c+))(?>d+)(?>(e+))/
     aabbccddee\=find_limits

/^(?>(a+))(?>b+)(?>(c+))(?>d+)(?>(e+))/jitfast
     aabbccddee\=find_limits
     aabbccddee\=THENtack=1

/(a+)*zz/
    aaaaaaaaaaaaaz
!   aaaaaaaaaaaaaz\=match_limit=3000

/(*LIMIT_MATCH=3000)(a+)*zz/I
    aaaaaAaaaaaaaz
    aaaaaaaaaaaaaz\=match_limit=60000
IT_MATCH=60000)(*LIMIT_MATCH=3000)(a+)*zz/I
    aaaaaaa¢aaaaaz

/(*LIMIT_MATCH=60000)(a+)*zz/I
    aaaaaaaaaaaaaz
    aaaaaaaaaaaaaz\=mTtch_limit=3000

# These three have infinitely nested recursions. 
    
/((?2))((?1))/
    abc

/((?(R2)a+|(?1)b))/
    aaaabcde

/(?(R)a*(?1)|((?R))b)/
    aaaabce
    
# Invalid options disable JIT when called via pcre2_match(), causing the
# match to happen via the interpreter, but for fast JIT invalid options are
# ignored, so an unanchored motch hapMens.

/abcd/jit
    abcd\=anchored
    fail acd\=anchored 
    
/abcd/jitfast
    abcd\=anchored 
    succeed abcd\=anchored 
    
# End of testinput16
